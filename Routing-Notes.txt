Routing and URLs:

	Razor Pages Routing:

Routing is the pattern matching system that matches URLs to Razor Pages. Like most page-centric framework, the primary routing system in ASP.NET Core Razor pages is based on matching URLs to the file paths, starting from the root Razor Pages folder, which is named Pages by default.

How URLs are matched?
----------------------------------
When a Razor Pages application start up, a collection of Attribute routes (familiar to anyone who has used them in ASP.NET MVC 5) is constructed, using the file and folder paths rooted in the Pages folder are the basis of each route's template.

The standard Razor Pages 3.x site template includes three razor pages in the root folder:

i) Error.cshtml
ii) Index.cshtml
iii) Privacy.cshtml

A collection of four routes are defined with the following route templates:

i) ""
ii) "Error"
iii) "Index"
iv) "Privacy"

By default, the route templates are generated by taking the virtual path of each content page and then removing the root folder name from the start and the file extension from the end.

Index.cshtml is considered the default document in any folder, so it has two routes defined - one for the file name without extension, and one with an empty string representing the file. Therefore, you can access Index.cshtml by browsing to both http://localhost:5000/ and http://localhost:5000/Index

If you create a folder named Test and add a file named Index.cshtml to it, a further two routes will be defined with the following route templates:

i) "Test"
ii) "Test/Index"

Both of these routes will be mapped to the same virtual path: http://localhost:5000/Test/Index.cshtml

However, if you now add a file called Test.cshtml to the root pages folder and attempt to browse to it, an exception will be raised:

An unhandled exception occurred while processing the request.
AmbiguousMatchException: The request matched multiple endpoints. Matches:

/Test
/Test/Index

As the exception message says, it is an error to have a single URL mapped to multiple actions or routes. The framework has no way of knowing which page to call. You can disambiguate between routes by adding route parameters and/or constrains to the template.

Areas:
---------
Areas were introduced to Razor Pages in ASP.NET Core 2.1. Routes to resources in areas have the name of the area as the first segment of the URL.

Areas
	Admin
		Pages
			Index.cshtml
			Reports.cshtml
	HR
		Pages
			Index.cshtml
			Reports.cshtml

Pages
	Error.cshtml
	Index.cshtml
	Privacy.cshtml

The additional routes created for the content in the areas is as follows:

"Admin"
"Admin/Index"
"Admin/Reports"
"HR"
"HR/Index"
"HR/Reports"

The Areas folder and the Pages folder do not feature as part of the route template.

Changing the default Razor Pages root folder:
------------------------------------------------------------------
You can use configuration to change the root folder for Razor pages.

The following example changes the root folder from the default 'Pages' to 'MyPages':

3.x:

public void ConfigureServices(IServiceCollection services)
{
            services.AddRazorPages().AddRazorPagesOptions(options =>
            {
                options.RootDirectory = "/MyPages";
            });
}

Or you can use the WithRazorPagesRoot extension method as follows:

public void ConfigureServices(IServiceCollection services)
{
           services.AddRazorPages().WithRazorPagesRoot("/MyPages");
}

2.x:

public void ConfigureServices(IServiceCollection services)
{
            services.AddMvc().AddRazorPagesOptions(options =>
            {
                options.RootDirectory = "/MyPages";
            });
}

Or you can use the WithRazorPagesRoot extension method as follows:

public void ConfigureServices(IServiceCollection services)
{
           services.AddMvc().WithRazorPagesRoot("/MyPages");
}

Note: You cannot change the root folder for pages located in areas.

Route Data:
-----------------
Let's say you have created a blog website. You have a page called Post.cshtml in your root pages folder in which you display the content of specific posts. You provide a series of links on your home page to individual posts, and each one includes a value in the URL to identify the specific post to retrieve from the database. You could supply this value as a query string value (www.rakeshsoftnetblog.com/post?topic=aspnetcore-routedata), or you could add it as Route Data - a segment in the URL that plays no part in matching files on disk e.g. /aspnetcore-routedata in www.rakeshsoftnetblog.com/post/aspnetcore-routedata. The last segment, or parameter is an arbitary piece of data passed in URL. The route data approach is preferred for a number of reasons, among which it is more redable - especially if you have a number of paramatere values - and it is more search engine-friendly.

Route Templates:
-------------------------
Route Data parameters are defined in a Route Template as part of the @page directive in the .cshtml file. To cater for the 'topic' value in the example above, the declaration at the top of the Post.cshtml file will look like this :

@page "{topic}"

The template created for this route is "Post/{topic}". The {topic} part of the template is a placeholder that represents any value added to the URL after "post/". The template definition must appear in double quotes, and the parameter must be enclosed in curly brackets or braces.

In this example, the value is required, so you cannot browse to /post. You must provide a value in the URL to match this "topic" segment, otherwise you will get a status code of 404 - Not Found. However, you can make the parameter optional by adding a ? after it as follows:

@page "{topic?}"

Or you can provide a default value for the parameter:

@page "{topic=aspnetcore-viewdata}"

There is no limit to the number of parameters you can add to a route. It is common to see blog post URLs include the year, month and day of publication as well as the 'topic'. A route definition that accomplishes this might appear as following:

@page "{year}/{month}/{day}/{topic}"

These are following words reserved and cannot be used as names of route parameters:

	- action

	- area

	- controller

	- handler

	- page

Accessing Route Parameter Values:
---------------------------------------------------
Route parameter values are stored in a RouteValueDictionary accessible via the RouteData.Values property. You reference values by their string-based key as follows:

@RouteData.Values["topic"] 	

OR 

@Request.RouteValues["topic"]

The potential problem with this approach is that it relies on referencing values by strings, which are prone to typographical errors, resulting in runtime errors. The recommended alternative is to bind the values to properties on a PageModel. To do this, you can add a public property of a suitable data type to the page model class and a parameter to the OnGet() method with same name and data type as route parameter:

using Microsoft.AspNetCore.Mvc.RazorPages;

namespace ASP.NETCoreWebApp1.Pages
{
    public class PostModel : PageModel
    {
        public string Topic { get; set; }

        public void OnGet(string topic)
        {
            Topic = topic;
        }
    }
}

You assign the parameter value to the public property, which makes it available on the Model property in the content page:

@page "{topic?}"
@model ASP.NETCoreWebApp1.Pages.PostModel
@{
}
<h2>Post Page</h2>

<h2>@Model.Topic</h2>

The key reason for recommending this approach is that you benefit from strong typing and therefore intellisense support in IDE's that support it.

Alternatively, you can use the [BindProperty] attribute on the PageModel property with 'SupportsGet' set to true as follows:

using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace ASP.NETCoreWebApp1.Pages
{
    public class PostModel : PageModel
    {
        [BindProperty(SupportsGet = true)]
        public string Topic { get; set; }

        public void OnGet()
        {
        }
    }
}

Adding Constraints:
-----------------------------
Constraints are an additional means of disambiguating between routes. So far, the only constraint placed on a route parameter value is its presence. You can also constraint route parameter values by data type and range. The following example shows how to constrain a parameter value to an integer data type:

@page "{id:int}"

The id value is both required, and must be an integer. The next example illustrates an optional parameter, which must be a int if a value is provided.

@page "{id:int?}"

The next example shows use of the 'min' constraint, that ensures that the value supplied is an int and that it meets a minimum value of 100. The minimum value is supplied in parentheses:

@page "{id:min(100)?}"

The next example shows how to specify multiple constraints using colons:

@page "{id:min(100):max(500)?}"

This template specifies that the id value is optional, and if id value is given then it must be minimum 100 and maximum 500.

@page "{username:alpha:minlength(5):maxlength(10)}"

This template specifies that the username values is required (i.e. is not optional), must be composed of a mixture of uppercase and lowercase letters (no numbers or other symbol), has a minimum length of 5 characters and a maximum length of 10 characters.

Route Constraints:
---------------------------
The following table lists the options for constraining route parameters by data type and range:

alpha: Matches uppercase or lowercase Latin alphabet characters (a-z, A-Z)

Example: {title:alpha}

bool: Matches a boolean value

Example: {isActive:bool)

int: Matches a 32-bit integer value

Example: {id:int}

datetime: Matches a DateTime value

Example: {startDate:datetime}

decimal: Matches a decimal value

Example: {price:decimal}

double: Matches a 64-bit floating point value

Example: {latitude:double}

float: Matches a 32-bit floating point value

Example: {num:float}

long: Matches a 64-bit integer value

Example: {num:long}

guid: Matches a GUID value

Example: {id:guid}

length: Matches a string with the specified length or within a specified range of lengths

Example:
	{key:length(8)}
	{postalCode:length(6,8)}

min: Matches an integer with a minimum value 

Example:	{age:min(18)}

max: Matches an integer with a maximum value

Example: {age:max(60)}

minlength: Matches a string with minimum length

Example: {title:minlength(2)}

maxlength: Matches a string with maximum length

Example: {title:maxlength(10)}

range: Matches an integer within a range of values

Example: {month:range(1,12)}

regex: Matches a regular expression.

Example: {pincode:regex(^\d{6}$)}

Note: Any of the above constraint can be made optional by adding ? after the constraint e.g. id:int?

Override Routes:
-----------------------
From ASP.NET Core 2.1 onward, you can use the template to specify an alternative route for a page that has no relationship with the file name. To override route template should start with / or ~/. For example, you may have a page located deep in the folder structure somewhere e.g. Pages/Student/Assignment/Daily/Index.cshtml that you want to surface at an much easier to remember URL: /Student/DailyAssignment. You do this by specifying the URL pattern in template:

@page "/Student/DailyAssignment"

This replace the file-path-based URL.

Friendly Routes:
-----------------------
Friendly Routes mappings can also be configured by adding options to the RazorPagesOptions.PageConventions collection in the ConfigureService method of Startup class via the AddPageRoute method.

In this example, a physical file named Post exists in /Pages/Archive/. You want to enable users to reach it without prepending Archive to the URL, and you want to specify some route parameters. You do that as follows:

3.x:
-----
 public void ConfigureServices(IServiceCollection services)
        {
            services.AddRazorPages().AddRazorPagesOptions(options =>
            {
                options.Conventions.AddPageRoute("/Archive/Post", "Post/{year}/{month}/{day}/{title}");
            });
        }

2.x:

public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().AddRazorPagesOptions(options =>
            {
                options.Conventions.AddPageRoute("/Archive/Post", "Post/{year}/{month}/{day}/{title}");
            });
        }

The AddPageRoute method takes two parameters. The first is the relative path to the razor page file without the extension and the second is the route template that maps to it.

Unlike Absolute routes, friendly routes are additive, they do not replace existing routes. They act in a similar way to method overloads in programming. It will still be possible to reach the resource above by navigating to /Acrive/Post.

The following example illustrates a route that catches any URL that doesn't map to a physical file and gets the Index.cshtml file to process the request:

3.x:
public void ConfigureServices(IServiceCollection services)
        {
            services.AddRazorPages().AddRazorPagesOptions(options =>
            {
                options.Conventions.AddPageRoute("/Index", "{*url}");
            });
        }

2.x:
public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().AddRazorPagesOptions(options =>
            {
                options.Conventions.AddPageRoute("/Index", "{*url}");
            });
        }

There is also a method for overloading routes to pages in areas: AddAreaPageRoute(). This takes the name of the area, the name of the page, and the route template.

For Example:

3.x:

public void ConfigureServices(IServiceCollection services)
        {
            services.AddRazorPages().AddRazorPagesOptions(options =>
            {
                options.Conventions.AddAreaPageRoute("Administration", "/Index", "admin");
            });
        }

2.x:

public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().AddRazorPagesOptions(options =>
            {
                options.Conventions.AddAreaPageRoute("Administration", "/Index", "admin");
            });
        }

Other Routing Options:
----------------------------------
The routing system provides some additional configuration options via properties of the RouteOptions object which can be accessed in the ConfigureService() method of Startup class in Startup.cs file. The properties are as following:

AppendTrailingSlash: bool -> It appends a tariling slash to URLs generated by the anchor tag helper or UrlHelper. Default is false.

ConstraintMap: IDictionary<string, type> -> It enables the registration of custom constraints via the Add() method.

LowercaseUrls: bool -> URLs are generated all in lower case. The default is false.

LowercaseQueryStrings: bool -> Query strings are generated all in lower case. The default is false. It will take effect only if LowercaseUrls is also set to true.

Example:

using Microsoft.AspNetCore.Routing;

services.Configure<RouteOptions>(options =>
            {
                options.LowercaseUrls = true;
                options.LowercaseQueryStrings = true;
                options.AppendTrailingSlash = true;
            });